# -*- coding: utf-8 -*-
"""Quantum_TruncatedSVD.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U1H-W2MhLH7J8NWc7J4A05vwLyNOr-fT
"""

import asyncio
import numpy as np
import pandas as pd
from sklearn.decomposition import TruncatedSVD
from qiskit import QuantumCircuit, transpile, assemble, Aer, execute
from qiskit.visualization import plot_bloch_multivector, plot_histogram
from qiskit.extensions import RXGate, RYGate, RZGate
from qiskit.circuit import Parameter
from qiskit.algorithms.optimizers import COBYLA
from qiskit_machine_learning.algorithms import VQC
from qiskit_machine_learning.datasets import ad_hoc_data
from dwave.system import LeapHybridSampler
from dwave.system.composites import EmbeddingComposite

# Define params
n_qubits = 2
params = Parameter("Î¸")

# Create simple quantum circuit
circuit = QuantumCircuit(n_qubits)
for qubit in range(n_qubits):
    circuit.ry(params, qubit)
circuit.cx(0, 1)

# Define quantum instance
quantum_instance = Aer.get_backend('qasm_simulator')

# Define classical optimizer (COBYLA)
optimizer = COBYLA(maxiter=100)

# Create variational quantum classifier (VQC)
vqc = VQC(num_qubits=2, feature_map=circuit, ansatz=circuit, optimizer=optimizer, quantum_instance=quantum_instance)

# Replace get_new_data with actual, using asyncio
async def get_new_data():
    # Replace function for data from real-time streaming datafeed
    await asyncio.sleep(1)
    return np.random.rand(1), np.random.rand(13)

# Using real-time streaming XLF and bond rates data
async def realtime_qml(xlf_closing_prices, bond_rates):
    # Concatenates the XLF closing prices and bond rates
    data = np.concatenate((xlf_closing_prices.reshape(-1, 1), bond_rates), axis=1)

    # Truncated SVD for extremely fast dimensionality reduction
    svd = TruncatedSVD(n_components=2)
    data_svd = svd.fit_transform(data)

    vqc.training_dataset = data_svd

    # Train VQC model
    vqc.run(quantum_instance)

    # Quantum annealing with D-Wave
    qubo = vqc.construct_circuit(data_svd[0]).decompose().to_matrix_op().to_opflow().to_weighted_pauli_operator().paulis[0][1].to_matrix()
    sampler = LeapHybridSampler()
    response = sampler.sample_qubo(qubo)

    print(response)

# Updating real-time: PCA 1, 2 feature values, strategy returns and portfolio returns as pca1, pca2, strategy_return, portfolio_return
asset1_perc_change = 0.01
asset2_perc_change = 0.02
pca1 = 0.5  # update this value in real time
pca2 = 0.4  # update this value in real time
strategy_return = 0.6  # update this value in real time
portfolio_return = 0.7  # update this value in real time

# Series of (6) Quantum Gate Operations. Changing the quantum state reflects the changing asset price 1 and 2, PCA 1, 2 feature values intraday, algo strategy returns, and portfolio returns
# Initialize a quantum circuit
qc = QuantumCircuit(6)

# Apply a rotation gate on the first qubit based on asset 1 price percentage change .01
qc.append(RXGate(asset1_perc_change), [0])

# Apply a rotation gate on the second qubit based on asset 2 price percentage change .02
qc.append(RXGate(asset2_perc_change), [1])

# Apply a rotation gate on the third qubit based on PCA 1
qc.append(RXGate(pca1), [2])

# Apply a rotation gate on the fourth qubit based on PCA 2
qc.append(RXGate(pca2), [3])

# Apply a rotation gate on the fifth qubit based on strategy_return
qc.append(RXGate(strategy_return), [4])

# Apply a rotation gate on the sixth qubit based on portfolio_return
qc.append(RXGate(portfolio_return), [5])

print(qc)

# Real-time datafeed loop
async def event_loop():
    while True:
        xlf_closing_prices, bond_rates = await get_new_data()
        await realtime_qml(xlf_closing_prices, bond_rates)

# Check if an event loop is already running
loop = asyncio.get_event_loop()

if loop.is_running():
    # In an interactive environment, such as Jupyter notebook, run in the existing loop
    task = loop.create_task(event_loop())
else:
    # If no event loop is running, create a new one and run
    try:
        loop.run_until_complete(event_loop())
    finally:
        loop.close()

# For distributed systems, handling multiple real-time tasks
# Each stream (changing asset prices, PCA 1, 2...) representing 1 local machine each
# Changing the quantum state for each quantum circuit run on a local machine (computer): reflecting the changing asset prices, PCA 1, 2 feature values intraday, algo strategy returns, and portfolio returns
import multiprocessing

def update_asset_prices():
    pass

def update_pca():
    pass

def update_strategy_returns():
    pass

def update_portfolio_returns():
    pass

if __name__ == '__main__':
    # Create processes for each task
    processes = [
        multiprocessing.Process(target=update_asset_prices),
        multiprocessing.Process(target=update_pca),
        multiprocessing.Process(target=update_strategy_returns),
        multiprocessing.Process(target=update_portfolio_returns)
    ]

    # Start all processes
    for p in processes:
        p.start()

    # Wait for all processes to finish
    for p in processes:
        p.join()

!pip install qiskit
!pip install qiskit_machine_learning

!pip install dwave-ocean-sdk
